
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Geek Woodworker</title>
  <meta name="author" content="靖天">
  <meta name="Generator" content="Jekyll & Octopress (http://octopress.org)">

  
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://ifq.github.com/blog/page/30/">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/octopress.min.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Geek Woodworker" type="application/atom+xml">
  

<!--Fonts from Google's Web font directory at http://google.com/webfonts -->
<link href='http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic' rel='stylesheet' type='text/css'>
<!-- 9jBDGwX2G-7pQ39zs-wElUxm5Tg -->
<meta name="alexaVerifyID" content="9jBDGwX2G-7pQ39zs-wElUxm5Tg" />

  
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-33860711-1']);
    _gaq.push(['_trackPageview']);

    (function() {
      var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>


   
  <link href="/octopress-favicon.png" rel="icon">
</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Geek Woodworker</a></h1>
  
    <h2>一个热爱木工的软件工程师</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:ifq.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main">
	<li><a href="/">主页</a></li>
	<li><a href="/archives">所有文章</a></li>
	<li><a href="/blog/categories">类别</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/2006/12/07/1/">世界上智慧最集中的一张照片</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2006-12-07T00:00:00+08:00" pubdate data-updated="true">Dec 7<span>th</span>, 2006</time>
         &bull; <a rel="bookmark" href="/blog/2006/12/07/1/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><div><div forimg="1"><img class="" src="/rc/legacy/d3a1f403f6f0bded08fa9396.jpg" width="800"><font size="5" color="#ff0000">太厉害了哈!教科书中的人物大汇集!<br>
<br>
<div forimg="1"><img class="" src="/rc/legacy/e232f8f22f908e12b07ec590.jpg" width="800"></div>
<font size="3" color="#000000">这张不知道大家见过没有哈</font></font></div></div></div>

  <footer>
    
    <p><a class="comments-link" href="/blog/2006/12/07/1/#disqus_thread" data-disqus-identifier="http://ifq.github.com/blog/2006/12/07/1/">View comments &raquo;</a></p>
    
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/2006/12/05/1/">McAfee Avert实验室预测的2007年十大安全威胁</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2006-12-05T00:00:00+08:00" pubdate data-updated="true">Dec 5<span>th</span>, 2006</time>
         &bull; <a rel="bookmark" href="/blog/2006/12/05/1/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><div><p >以下是McAfee Avert实验室预测的2007年十大安全威胁如下(排名不分先后)：</p >
<p >1、假冒流行在线服务网站(比如eBay)登录页面盗取密码的站点不断增加</p >
<p >2、垃圾邮件的数量继续上升&mdash;&mdash;尤其是消耗带宽的图像垃圾邮件</p >
<p >3、视频共享的不断普及不可避免地导致黑客把MPEG文件锁定为传播恶意代码的新方式</p >
<p >4、更加智能和更多连接移动设备使移动电话攻击更加普遍</p >
<p >5、商业潜在非预期程序(PUP)的不断增长致使广告软件成为主流</p >
<p >6、身份盗窃和数据丢失继续成为公众问题</p >
<p >7、僵尸网络和自动程序成为黑客的最爱</p >
<p >8、寄生恶意软件和可更改现有文件的病毒重新爆发</p >
<p >9、32位平台的保护和修复能力得到提高但相应的Rootkits数量也不断增加</p >
<p >10、安全漏洞继续得到关注</p ></div></div>

  <footer>
    
    <p><a class="comments-link" href="/blog/2006/12/05/1/#disqus_thread" data-disqus-identifier="http://ifq.github.com/blog/2006/12/05/1/">View comments &raquo;</a></p>
    
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/2006/12/04/3/">一些关于Windows APS驱动及控制的资料</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2006-12-04T00:00:00+08:00" pubdate data-updated="true">Dec 4<span>th</span>, 2006</time>
         &bull; <a rel="bookmark" href="/blog/2006/12/04/3/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><div>这两天在网上查了下,找到一些有用的资料.首先是这个:<a target="_blank" href="ftp://ftp.software.ibm.com/pc/pccbbs/mobiles_pdf/aps2mst.pdf">ftp://ftp.software.ibm.com/pc/pccbbs/mobiles_pdf/aps2mst.pdf</a><br>
这是IBM官方关于APS的白皮书.介绍的很详细,包括APS程序包主要文件及其功能.<br>
<font color="#003366">ShockPrf.sys: kernel mode device driver for prediction algorithm and hard disk drive control&nbsp;&nbsp; Shockmgr.sys: kernel mode driver for miscellaneous operation <br>
Sensor.dll: application interface dll <br>
TpShCPL.cpl: control applet <br>
TpShocks.exe: task tray application <br>
TpShCPL.dll: bitmap resource file for this application program <br>
TpShPrm.hta: promotion pop-up window <br>
TpShPrm.gif: animation for promotion pop-up window <br>
TpShPrm.jpg: banner picture for promotion pop-up window</font><br>
其中最主要的就是前三个.而两个sys文件是驱动文件,第三个DLL文件是封装给程序使用的库.<br>
用eXeScope 查看Sensor.dll export的函数:<br>
<font color="#003300">Ordinal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Name<br>
00000001&nbsp;&nbsp;&nbsp;&nbsp; 10001960&nbsp;&nbsp;&nbsp;&nbsp; ShockproofCallSMAPIBIOS<br>
00000002&nbsp;&nbsp;&nbsp;&nbsp; 10001310&nbsp;&nbsp;&nbsp;&nbsp; ShockproofControl<br>
00000003&nbsp;&nbsp;&nbsp;&nbsp; 100018D0&nbsp;&nbsp;&nbsp;&nbsp; ShockproofEnableDisableSnooze<br>
00000004&nbsp;&nbsp;&nbsp;&nbsp; 100015E0&nbsp;&nbsp;&nbsp;&nbsp; ShockproofGetAccelerometerData<br>
00000005&nbsp;&nbsp;&nbsp;&nbsp; 10001640&nbsp;&nbsp;&nbsp;&nbsp; ShockproofGetAccelerometerDataEx<br>
00000006&nbsp;&nbsp;&nbsp;&nbsp; 10001560&nbsp;&nbsp;&nbsp;&nbsp; ShockproofGetAccelerometerMutex<br>
00000007&nbsp;&nbsp;&nbsp;&nbsp; 100012B0&nbsp;&nbsp;&nbsp;&nbsp; ShockproofGetAutoDisable<br>
00000008&nbsp;&nbsp;&nbsp;&nbsp; 100014F0&nbsp;&nbsp;&nbsp;&nbsp; ShockproofGetShockStatus<br>
00000009&nbsp;&nbsp;&nbsp;&nbsp; 10001500&nbsp;&nbsp;&nbsp;&nbsp; ShockproofGetSlaveCPUinfo<br>
0000000A&nbsp;&nbsp;&nbsp;&nbsp; 10001480&nbsp;&nbsp;&nbsp;&nbsp; ShockproofGetUnloadCnt<br>
0000000B&nbsp;&nbsp;&nbsp;&nbsp; 10001360&nbsp;&nbsp;&nbsp;&nbsp; ShockproofGetVersion<br>
0000000C&nbsp;&nbsp;&nbsp;&nbsp; 10001B30&nbsp;&nbsp;&nbsp;&nbsp; ShockproofInformMouseDevChange<br>
0000000D&nbsp;&nbsp;&nbsp;&nbsp; 100019C0&nbsp;&nbsp;&nbsp;&nbsp; ShockproofInformPENevent<br>
0000000E&nbsp;&nbsp;&nbsp;&nbsp; 100016A0&nbsp;&nbsp;&nbsp;&nbsp; ShockproofInformPMevent<br>
0000000F&nbsp;&nbsp;&nbsp;&nbsp; 10001A20&nbsp;&nbsp;&nbsp;&nbsp; ShockproofInformTabletLIDstate<br>
00000010&nbsp;&nbsp;&nbsp;&nbsp; 10001810&nbsp;&nbsp;&nbsp;&nbsp; ShockproofInvokeSnooze<br>
00000011&nbsp;&nbsp;&nbsp;&nbsp; 10001780&nbsp;&nbsp;&nbsp;&nbsp; ShockproofManualSensitivitySetting<br>
00000012&nbsp;&nbsp;&nbsp;&nbsp; 100015B0&nbsp;&nbsp;&nbsp;&nbsp; ShockproofReleaseAccelerometerMutex<br>
00000013&nbsp;&nbsp;&nbsp;&nbsp; 10001270&nbsp;&nbsp;&nbsp;&nbsp; ShockproofSetAutoDisable<br>
00000014&nbsp;&nbsp;&nbsp;&nbsp; 10001840&nbsp;&nbsp;&nbsp;&nbsp; ShockproofSnoozeSetting<br>
00000015&nbsp;&nbsp;&nbsp;&nbsp; 100016D0&nbsp;&nbsp;&nbsp;&nbsp; ShockproofTaskComplete<br>
<font color="#000000"><br>
在众多函数中最有价值的莫过于</font></font><font color="#ff0000">ShockproofGetAccelerometerData<font color="#000000">这个函数.它可以得出传感器输出的数据.输出数据的结构如下:<br>
<font color="#333300">typedef struct _ACCELREPORT {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; INT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; PresentState;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Current internal state (stable: 0, unstable1: 1: unstable2: 2)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USHORT&nbsp;&nbsp;&nbsp; LatestRawAccelDataX; // latest raw acceleration data of X axis&nbsp;&nbsp;&nbsp;&nbsp; &lt;&#8211; works!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USHORT&nbsp;&nbsp;&nbsp; LatestRawAccelDataY; // latest raw acceleration data of Y axis&nbsp;&nbsp;&nbsp;&nbsp; &lt;&#8211; works!<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USHORT&nbsp;&nbsp;&nbsp; LatestAccelDataX;&nbsp;&nbsp;&nbsp;&nbsp; // latest acceleration data of X axis (average in 40ms)&nbsp;&nbsp;&nbsp; &lt;&#8211; Works even better?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USHORT&nbsp;&nbsp;&nbsp; LatestAccelDataY;&nbsp;&nbsp;&nbsp;&nbsp; // latest acceleration data of Y axis (average in 40ms)&nbsp;&nbsp;&nbsp; &lt;&#8211; Works even better?<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CHAR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Temperature;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // latest temperature<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USHORT&nbsp;&nbsp;&nbsp; LatestZeroG_X;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // latest zero-G offset of X axis&nbsp;&nbsp; &lt;&#8211; Seems to be the current notion of &#8220;center&#8221;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; USHORT&nbsp;&nbsp;&nbsp; LatestZeroG_Y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // latest zero-G offset of Y axis&nbsp;&nbsp; &lt;&#8211; &#8220;&#8221;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } ACCELREPORT;</font><br>
数据的实际意义我还有搞清楚,但是感觉不像是个加速度传感器输出的数值,更像是个陀螺仪之类.是一个X,Y坐标.利用这个函数就可以做一些有意思的事情.比如配合windows API :LockWorkStation()就可以做个机器锁定并防盗的程序.<br>
<br>
<font color="#ff0000">另外还找到一片英文的短文:</font><br>
</font></font>
<pre>IBM ThinkPad Accelerometer, aka "Active Protection System"<br><br>Announced in November 2003;&nbsp;&nbsp; Probably shipped in 2004 March<br><br>Analog Devices Inc (ADI) make the sensor and boast about it in their Press Releases<br><br>Probably an ADXL311 originally and now switched to ADXL320 since the first is getting deprecated.<br><br>These eat 3 volts at about 400 micro-amps and give 2 analogue outputs back, X and Y.<br><br>At rest in the horizontal plane these will both be measuring 1g .<br><br>Falling is more than than this, rising is less than this.<br><br>Tilt is collected as gavity decreases in a sin() as the chip is tilted through 90^ degrees.<br><br>Still puzzled about *where* the values are being read in from<br><br>Initial assumption was a chip on the I2C/SMBUS.&nbsp;&nbsp; But since it's a 2-channel a-to-d, could be anyway<br>---eg, existing fan monitoring chip.<br><br>Windows drivers read in 28-bytes via an IOCTL(0x733fc) on "\ShockMgr" .&nbsp;&nbsp; (See shockprf.sys)<br><br>Apple is shipping a 2-axis sensor in new PowerBooks.&nbsp;&nbsp; Acccessed via the smbus.<br>dead easy since we have (some) info.<br><br>Referred to as "Sudden Motion Sensor".&nbsp;&nbsp; and "Mobile Motion Module".&nbsp;&nbsp; and "Apple Motion Sensor"<br>uni-n@f8000000/i2c@f8001000/i2c-bus@1/accelerometer@b0<br>pci@f2000000/mac-io@17/gpio@50/accelerometer-1@13<br>pci@f2000000/mac-io@17/gpio@50/accelerometer-2@14<br><br>Compaq has a sensor in some of their Tablet PCs to tell which way the display is rotated/pointing (Also ADI)<br><br>Windows Driver:<br>===============<br><br>From:<br>&nbsp;&nbsp; ftp://ftp.software.ibm.com/pc/pccbbs/mobiles_pdf/aps2mst.pdf<br><br>&nbsp;&nbsp;&nbsp;&nbsp; The active protection system employs a heuristic learning algorithm to track<br>&nbsp;&nbsp; system orientation. <strong>The Shock Manager, a system thread created by the<br>&nbsp;&nbsp; Shockprf.sys of a kernel mode device driver,</strong> analyzes the variations in acceleration<br>&nbsp;&nbsp; and collects system orientation data into the Shock History Database. The collected<br>&nbsp;&nbsp; data is then used to tune sensitivity and predict excessive shocks. This tuning is<br>&nbsp;&nbsp; important in minimizing the disk performance penalty caused by prediction<br>&nbsp;&nbsp; failures. Once the Shock Manager detects a certain variation which may be<br>&nbsp;&nbsp; equivalent to one usually seen just before receiving an excessive shock, the <strong>Shock<br>&nbsp;&nbsp; Manager acts immediately to stop the hard disk drive</strong>.<br><br>The writes to 0xed are just to the ("non-existant") delay port.<br><br>The other two ports are super-I/O controller/IDE ports and I think the<br>write is to stop the drive and then stop the IDE Bus.<br></pre>
还没有细看,空了再说,睡觉了,大家晚安.<br>
<font color="#ff0000"><font color="#000000"><br>
<br>
</font></font><font color="#ff0000"></font></div></div>

  <footer>
    
    <p><a class="comments-link" href="/blog/2006/12/04/3/#disqus_thread" data-disqus-identifier="http://ifq.github.com/blog/2006/12/04/3/">View comments &raquo;</a></p>
    
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/2006/12/04/2/">几个冷笑话,miula提供~</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2006-12-04T00:00:00+08:00" pubdate data-updated="true">Dec 4<span>th</span>, 2006</time>
         &bull; <a rel="bookmark" href="/blog/2006/12/04/2/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><div>2 <br />
小蛇很慌张地问大蛇哥哥..&quot;哥哥，我们有没有毒？？&quot; <br />
大蛇说:&quot;你问这干吗.？&quot; <br />
小蛇说:&quot;我刚才不小心把自己舌头咬到了。&quot;<br />
<br />
3 <br />
有根火柴棒,走着走着突然觉得头很痒,就去挠,用力过猛着了火&#8230;&#8230;&nbsp;&nbsp; <br />
去医院急救,出来后，它变成了一根棉签&#8230;&nbsp;&nbsp; <br />
<br />
4 <br />
一只鸡挨狗追~~~实在跑得不行了~~~就发了起来~~~越飞越高~~最后变成了飞机（鸡）~~ <br />
<br />
5 <br />
一天，一块三分熟的牛排在街上走着，突然他看到前方有一块五分熟的牛排，可他们却相互没大招呼。 <br />
问：为什么他们没打招呼？ <br />
答：因为他们不熟&hellip;&hellip; <br />
<br />
6 <br />
妻:我真是瞎了眼踩到狗屎才会嫁给你。 <br />
夫:我才真是瞎了眼踩到狗屎才会娶妳。 <br />
&#8230; <br />
狗屎:我好倒霉喔！躺在那里都被你们俩给踩到.. <br />
<br />
7 <br />
有兩顆番茄去逛街, <br />
第一顆番茄突然走的很快,第二顆番茄就問:我們要去哪裡阿!? <br />
第一顆番茄没回答,所以第二顆番茄又問了一次 <br />
第一顆又番茄没回答,所以第二顆番茄又再問了一次 <br />
第一顆番茄終於慢慢轉頭說 <br />
&#8230;..我們會講話嗎!?</div></div>

  <footer>
    
    <p><a class="comments-link" href="/blog/2006/12/04/2/#disqus_thread" data-disqus-identifier="http://ifq.github.com/blog/2006/12/04/2/">View comments &raquo;</a></p>
    
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/2006/12/04/1/">Google Earth上的FireFox麦田圈圈</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2006-12-04T00:00:00+08:00" pubdate data-updated="true">Dec 4<span>th</span>, 2006</time>
         &bull; <a rel="bookmark" href="/blog/2006/12/04/1/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><div><div forimg="1"><img class="" src="/rc/legacy/6071b9a1ce6e6a8a47106495.jpg" width="800"></div>
<div class="post-body">
<p>　　其实这个FireFox麦田怪圈早已经画好了，不过最近Google Earth才更新了地图，使得现在才能在Google Earth中看到一个真实的FireFox麦田怪圈。现在应该没有人认为这是假的了吧。</p>
<p>　　这个FireFox的Logo直径220英尺，经过2周的精心策划加上18个人的共同协作在24小时内完成的。</p>
<p>　　和其他麦田怪圈不一样的是，这个FireFox麦田怪圈在制作前经过了大量媒体的宣传，制作者花费了很多时间和精力，甚至动用2架直升机，最终完成了这个伟大作品。应该没有人认为这是外星人做的了。</p>
<p>　　点击下载地标文件：<a href="http://www.williamlong.info/google/upload/178_Firefox_Crop_Circle.kml">Google Earth上的FireFox</a></p>
</div></div></div>

  <footer>
    
    <p><a class="comments-link" href="/blog/2006/12/04/1/#disqus_thread" data-disqus-identifier="http://ifq.github.com/blog/2006/12/04/1/">View comments &raquo;</a></p>
    
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/2006/12/03/1/">转载-解析windows下IBM硬盘保护装置APS驱动</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2006-12-03T00:00:00+08:00" pubdate data-updated="true">Dec 3<span>rd</span>, 2006</time>
         &bull; <a rel="bookmark" href="/blog/2006/12/03/1/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><div><font face="arial,helv,helvetica" color="#ff9900" size="2"><font face="arial,helv,helvetica">本文全面记述了</font></font><font color="#ff9900" size="2"> </font><font face="arial,helv,helvetica" color="#ff9900" size="2"><font face="arial,helv,helvetica">Mark A. Smith调试APS驱动,解析出接口,并在linux实现APS驱动的过程.有空试着翻译下.</font></font><br>
<font face="arial,helv,helvetica" color="#000000" size="-1"><font face="arial,helv,helvetica" color="#000000" size="3">The ThinkPad APS Accelerometer Interface</font><br>
</font>
<p><font face="arial,helv,helvetica" color="#000000" size="-1">In late 2003, IBM announced a feature called the Active Protection System (APS) in some of its line of ThinkPads. This feature is used to &#8220;park&#8221; the hard disk head when sudden motion or acceleration (such as being dropped) is detected. A parked head has much less chance of damaging data than if the head is over sectors containing data when impact occurs. The system proved very valuable and other vendors followed suit. In early 2005, Apple announced their <a href="http://www.kernelthread.com/software/ams/">Sudden Motion Sensor</a> system as an addition to their PowerBook line. </font></p>
<p><font face="arial,helv,helvetica" color="#000000" size="-1">All of these systems use accelerometers placed on the motherboard to detect motion. A kernel software driver interfaces with the accelerometer and exposes its acceleration readings to interested user-space programs. The Mac OS X system is described in detail by Amit Singh in the previously referenced article. The Windows system on ThinkPads has not been described in detail, and there was no port for Linux. </font></p>
<p><font face="arial,helv,helvetica" color="#000000" size="-1">I was interested in interfacing with the accelerometer from Linux, mostly for the sake of curiosity, but I also wanted to show Amit that his TT can&#8217;t hold corners as well as my Corolla (and if I could prove it to him using Linux, so much the better). Any such port was certainly to begin with a thorough understanding of the Windows APS. </font></p>
<p><font face="arial,helv,helvetica" color="#000000" size="-1">Fortunately, I know another crazy Windows kernel hacker, Anurag Sharma. Anu is known for using computer terminology to describe even his inner workings. For example, when the conversation changes topics, he&#8217;ll sometimes announce, &#8220;Just a second, I&#8217;ve got to swap out and page in.&#8221; And, when doing a task without all of the information he would like, he will say &#8220;I&#8217;m performing speculative execution, bear with me.&#8221; We started a kernel debugging session over serial cable using Windbg. We discovered that APS is comprised of two drivers, shockprf.sys and shockmgr.sys. shockprf.sys interfaces with the accelerometer hardware, while shockmgr.sys subscribes to the data from shockprf.sys and must be the component used to initiate parking of the drive head. Since we were primarily interested in the protocol used to get information out of the accelerometer, our debugging focused on shockprf.sys. </font></p>
<p><font face="arial,helv,helvetica" color="#000000" size="-1">We discovered that shockprf.sys was performing port I/O in the range 0x1600 to 0x162f. We looked at the values that shockmgr.sys was reading out of shockprf.sys and watched for those values to come in through shockprf.sys&#8217; port reads. We discovered a pattern of port writes and reads which repeatedly produced the values that shockmgr.sys was interested in. Armed with the read/write sequence that the accelerometer responded to from Windows, the task was now to produce a Linux driver which did the same thing. </font></p>
<p><font face="arial,helv,helvetica" color="#000000" size="-1">Since the amount of data that the accelerometer produces is very small, I decided the best way to expose it in Linux was through the /proc filesystem. I wrote a quick kernel module. Behold! Acceleration values! I performed a hard boot to make sure that everything would still work, and unfortunately, it did not. There was a bit of initialization port I/O that we missed. More protocol analysis from the Windows side produced our initialization sequence. After adding that code to the Linux driver, all was well. </font></p>
<p><font face="arial,helv,helvetica" color="#000000" size="-1">I could finally prove to Amit that his TT was slow. We strapped the ThinkPad into the passenger seats of both of our cars and drove up our <a href="http://maps.google.com/maps?q=bernal+rd.+95120&amp;ll=37.214856,-121.798253&amp;spn=0.028410,0.038195&amp;t=k&amp;hl=en">&#8220;closed course.&#8221;</a> He destroyed me. Although I refuse to give Amit the pleasure of my posting our comparative graphs, I will post the noteworthy performance of Anu&#8217;s new 350Z.</font></p>
<p><font face="arial,helv,helvetica" color="#000000" size="-1"><img class="" src="/rc/legacy/anufull.jpg" width="800"> </font></p>
<p><font face="arial,helv,helvetica" color="#000000" size="-1">As far as I could tell, the accelerometer in the ThinkPad has a 5 microsecond refresh rate. This is fast enough for most real-world applications. Although the lateral G values are probably slightly exaggerated due to body roll, it is interesting to note the relative detail in the graph. At time 520, there&#8217;s a stop sign. One can observe Anu&#8217;s acceleration become negative (breaking) approaching the stop sign, and then become sharply positive (forward acceleration). One can also see him shift at times 580 and 620. One can also deduce rough gearbox ratios between 1st, 2nd, and 3rd gears based on his acceleration values in each gear. Whether Anu accelerates through corners is also evident. Further, if one was interested in Anu&#8217;s speed, he would only need to integrate the green curve (assuming a flat course, uphill courses will give slightly higher forward acceleration values than actually achieved, assuming calibration on flat ground). Unfortunately, the ThinkPad accelerometers seem only to expose &#8220;X&#8221; and &#8220;Y&#8221; acceleration values. Unlike the PowerBook, &#8220;Z&#8221; values (or &#8220;up&#8221; and &#8220;down&#8221; acceleration) are not available.</font></p>
<h2><font face="arial,helv,helvetica" color="#000000" size="-1">Kernel Module</font></h2>
<p><font face="arial,helv,helvetica" color="#000000" size="-1">I am not permitted to release my source code yet, but I am working to make it available. However, I am permitted to describe how it works. Below is a detailed description of how my Linux kernel module communicates with the ThinkPad accelerometer.</font></p>
<p><font face="arial,helv,helvetica" color="#000000" size="-1">My driver is written as four files: </font></p>
<ul><font face="arial,helv,helvetica" color="#000000" size="-1">
<li>
<p style="MARGIN-BOTTOM: 0in">One containing acceleration common functions </p>
</li>
    <li>
<p style="MARGIN-BOTTOM: 0in">One containing proc functionality </p>
</li>
    <li>
<p style="MARGIN-BOTTOM: 0in">One containing thread functions for asynchronous reading </p>
</li>
    <li>
<p>One containing kernel module initialization and entry points </p>
</li>
</font></ul>
    <p><font face="arial,helv,helvetica" color="#000000" size="-1">They rely on a packed accelerometer_data structure which contains: </font></p>
    <ul><font face="arial,helv,helvetica" color="#000000" size="-1">
<li>
<p style="MARGIN-BOTTOM: 0in">an unsigned char representing the accelerometer state </p>
</li>
        <li>
<p style="MARGIN-BOTTOM: 0in">an unsigned short representing the X acceleration value </p>
</li>
        <li>
<p style="MARGIN-BOTTOM: 0in">an unsigned short representing the Y acceleration value </p>
</li>
        <li>
<p style="MARGIN-BOTTOM: 0in">an unsigned char representing the temperature of the accelerometer in Celsius. </p>
</li>
        <li>
<p style="MARGIN-BOTTOM: 0in">an unsigned short representing some variation (maybe a weighted average of the previous n readings?) of the X acceleration value </p>
</li>
        <li>
<p style="MARGIN-BOTTOM: 0in">an unsigned short representing some variation (maybe a weighted average of the previous n readings?) of the Y acceleration value </p>
</li>
        <li>
<p style="MARGIN-BOTTOM: 0in">an unsigned char representing the temperature of the accelerometer in Celsius (again?). </p>
</li>
        <li>
<p style="MARGIN-BOTTOM: 0in">an unsigned char of unknown use. </p>
</li>
        <li>
<p>an unsigned char indicating whether the mouse and keyboard are in use. </p>
</li>
</font></ul>
        <p><font face="arial,helv,helvetica" color="#000000" size="-1">Understanding what I mean by a latch is also important for understanding this logic. In this context, a latch is simply an I/O port and a value. To “wait for a latch” is to wait for an inb from that port to produce a specified value by repeatedly performing inb&#8217;s and checking the value. To check a latch is simply to do a single inb from the port and to report whether the value read from that port is the same as a specified value. The accelerometer uses these “latches” for synchronization: reporting data ready, and handshaking.</font></p>
        <p><font face="arial,helv,helvetica" color="#000000" size="-1">My acceleration common functions file contains functions which perform the following: </font></p>
        <ul><font face="arial,helv,helvetica" color="#000000" size="-1">
<li>
<p style="MARGIN-BOTTOM: 0in">A static function which <strong>checks a port latch</strong> for a certain value. <br>
This function simply takes an unsigned short port value and an unsigned char compare value and returns whether the inb from the specified port (bitwise anded with 0xff) yields the specified value. No waiting is done here. </p>
</li>
            <li>
<p style="MARGIN-BOTTOM: 0in">A static function which <strong>waits for a latch</strong> to have a certain value <br>
This function also takes an unsigned short port value and an unsigned char compare value. It loops over check_latch 10 times, udelaying 5 microseconds each time, waiting for the check to become true. (A latch seems like it never takes more than 50 microseconds to become set). I return whether the latch value becomes the specified value within the allotted time. </p>
</li>
            <li>
<p style="MARGIN-BOTTOM: 0in">A static function which <strong>checks the refresh state</strong> of the accelerometer data <br>
This simple issues a latch <strong>check</strong> of port 0x1604 for value 0x50 </p>
</li>
            <li>
<p style="MARGIN-BOTTOM: 0in">A static function which <strong>issues a refresh request</strong> to the accelerometer. <br>
This function takes a single argument which tells it whether to refresh synchronously or not. This function first issues a refresh state check, if it is already refreshed, it returns success. If not, it does an outb at port 0x1610 of value 0x11, and then an outb at port 0x161f of value 0x1. If the synchronous flag is set, it does a latch wait on port 0x1604 for value 0x50. The function then returns whether the latch wait was successful. </p>
</li>
            <li>
<p style="MARGIN-BOTTOM: 0in">A non-static function which <strong>reads the accelerometer data</strong>. <br>
This function takes an accelerometer_data structure and returns whether the read was successful. It issues a synchronous accelerometer data refresh request (which is likely to return immediately since the refresh latch is likely already set). If this refresh fails, this function returns the failure. Otherwise, it reads ports 0x1611 through 0x161E, assigning the 13 bytes worth of values to the 13 bytes large accelerometer_data structure. It then tells the accelerometer that it is done reading the data. It then issues an asynchronous refresh request and exits successfully. </p>
</li>
            <li>
<p style="MARGIN-BOTTOM: 0in">A static function which <strong>tells the accelerometer that it is done</strong> reading the data <br>
This function does two port reads. One art port 0x161f, and the next at port 0x1604, discarding the values it gets. </p>
</li>
            <li>
<p>A non-static function which <strong>initializes the accelerometer.</strong> <br>
This lengthy function takes a timeout value (in seconds) as the maximum time that it should take to try to initialize itself. I initialize a &#8220;seconds waited so far&#8221; variable to zero. I issue an outb at port 0x1610 of value 0x13, followed by an outb at port 0x161f of value 0x01. I then wait for latch 0x161f for value 0x0, and then wait for latch 0x1611 for value 0x3. Three more outbs at ports 0x1610, 0x1611, and 0x161f of values 0x17, 0x81, and 0x01, respectively follow. Four more waits for latches 0x161f, 0x1611, 0x1612, and 0x1613 for values 0x0, 0x0, 0x60, and 0x0 respectively follow. Then three more outbs at ports 0x1610, 0x1611, and 0x161f of values 0x14, 0x01, and 0x01 respectively follow. Then I wait for latch 0x161f for value 0x0. Then five outbs at ports 0x1610, 0x1611, 0x1612, 0x1613, and 0x161f of values 0x10, 0xc8, 0x00, 0x02, and 0x01 respectively follow. I then wait for latch 0x161f for value 0x0 again. I then issues a synchronous refresh of the accelerometer data, and wait for latch 0x1611 to become 0x0. The next part is a little bit tricky because it can take a long time for the accelerometer to complete. I loop forever until latch 0x1611 becomes 0x02. Inside this loop, I check the timeout value against the &#8220;time waited so far&#8221; variable. If the function has taken too long, we return failure. Otherwise, I call the function which reads the accelerometer data and I throw away the (probably garbage) data (this read somehow seems to kick the accelerometer into being initialized). I set_current_state to TASK_INTERRUPTIBLE, and schedule_timeout for HZ. I then increment our &#8220;seconds waited so far&#8221; variable and continue the loop. If the loop ever exits successfully, the function returns success. A good value to pass for the initialize timeout value is 10 seconds. </p>
</li>
</font></ul>
            <p><font face="arial,helv,helvetica" color="#000000" size="-1">My acceleration proc functions file only implements open, release, and read. </font></p>
            <ul><font face="arial,helv,helvetica" color="#000000" size="-1">
<li>
<p style="MARGIN-BOTTOM: 0in">open simply starts the read thread (if it is not already started) in the acceleration thread functions file. </p>
</li>
                <li>
<p style="MARGIN-BOTTOM: 0in">release stops the aforementioned read thread. </p>
</li>
                <li>
<p>read simply spits out the last acceleration_data structure that was read by the read thread. (Of course, this structure is protected by a semaphore). </p>
</li>
</font></ul>
                <p><font face="arial,helv,helvetica" color="#000000" size="-1">My acceleration thread functions file implements a function which is constantly reading. </font></p>
                <ul><font face="arial,helv,helvetica" color="#000000" size="-1">
<li>
<p>The read thread first daemonizes, then loops over a volatile variable which is set the the proc release function which tells this thread to stop. It then issues a read of the accelerometer data (of course, protected by a semaphore). It then set_current_state&#8217;s to TASK_INTERRUPTABLE, and schedule_timeout&#8217;s to a value passed in as a module parameter (I made the refresh rate settable at insmod time), or an appropriate default value. </p>
</li>
</font></ul>
                    <p><font face="arial,helv,helvetica" color="#000000" size="-1">My acceleration kernel module initialization and entry points file contains the regular kernel module init stuff. </font></p>
                    <ul><font face="arial,helv,helvetica" color="#000000" size="-1">
<li>
<p style="MARGIN-BOTTOM: 0in">The init function requests region for the specified port range, inits the accelerometer, does an initial read, initializes semaphores, create_proc_entry&#8217;s, and sets the entry&#8217;s proc_fops to a file_operations structure with .open, .read and .release initialized. </p>
</li>
                        <li>
<p>The exit function remove_proc_entry&#8217;s, makes sure the read thread is stopped, and releases region. </p>
</li>
</font></ul></div></div>

  <footer>
    
    <p><a class="comments-link" href="/blog/2006/12/03/1/#disqus_thread" data-disqus-identifier="http://ifq.github.com/blog/2006/12/03/1/">View comments &raquo;</a></p>
    
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/2006/11/30/2/">转载-在linux下实现基于加速度传感器的&amp;#34;敲打&amp;#34;命令</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2006-11-30T00:00:00+08:00" pubdate data-updated="true">Nov 30<span>th</span>, 2006</time>
         &bull; <a rel="bookmark" href="/blog/2006/11/30/2/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><div><table height="93" cellspacing="0" cellpadding="0" width="642" border="0">
<tbody>
    <tr valign="top">
    <td width="100%">
<h1 align="left"><font color="#808000" size="4">Linux 笔记本基于 “敲打” 的命令</font></h1>
    <p><em>在一台启用了 HDAPS 内核、具有加速器和对应的 Perl 脚本的笔记本上进行有意义的敲打</em></p>
<em><img class="" src="/rc/legacy/c.gif" width="800"></em></td>
</tr>
</tbody>
</table>
<table cellspacing="0" cellpadding="0" width="100%" border="0">
<tbody>
    <tr valign="top">
    <td width="10"><img class="" src="/rc/legacy/c.gif" width="800"></td>
    <td width="100%">
<p><a href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#author">Nathan Harrington</a> (<a href="mailto:harrington.nathan@gmail.com?subject=Linux%20%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%9F%BA%E4%BA%8E%20%E2%80%9C%E6%95%B2%E6%89%93%E2%80%9D%20%E7%9A%84%E5%91%BD%E4%BB%A4">harrington.nathan@gmail.com</a>), 程序员, IBM<br>
</p>
    <p>2006 年 9 月 14 日</p>
<blockquote>有 史以来第一次，您可以敲打一下计算机并得到有意义的响应！使用 Linux&reg; 和 Hard Drive Active Protection System（硬盘活动保护系统，HDAPS）内核驱动程序，我们可以访问 Lenovo（以前称为 IBM&reg;）ThinkPads 上的嵌入式加速器，然后处理加速器的数据来读取特定 “敲打” 事件序列（也就是您使用关节敲打笔记本的事件序列），并基于这些敲打事件运行一些命令。双击锁定屏幕，然后敲入密码来解锁。敲打显示屏一次就可以让 MP3 播放器前进一个音轨。这类可能事物是无穷无尽的。</blockquote>
<p>2003 年，IBM 开始发行集成了加速器和相关软件的 ThinkPad 笔记本，以便在笔记本掉到地上时对硬盘进行保护。来自 IBM 和其他地方的黑客已经为 Linux 内核开发了一些模块来利用这些传感器的优点。屏幕显示方向、桌面切换、甚至是游戏控制和实时的笔记本倾斜度 3D 模块现在都已经可以使用了。本文将展示 “敲打代码” 这种新技术和一个简单程序，该程序在检测到特定的敲打代码时会运行一些命令。</p>
    <p>使用带有 HDAPS 驱动的已更新的内核，我们就可以用一个简单程序 knockAge 来生成敲打代码了。我们也可以下载并使用一个 Perl 脚本来定制自己的敲打输入环境。请参阅本文最后的 <a href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#download">下载</a> 和 <a href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#resources">参考资料</a> 部分给出的链接，其中包括了解 knockAge 操作的链接。</p>
    <p><a name="N10072"><span class="atitle">硬件需求</span></a></p>
    <table cellspacing="0" cellpadding="0" width="40%" align="right" border="0">
    <tbody>
        <tr>
            <td width="10"><img class="" src="/rc/legacy/c.gif" width="800"></td>
            <td>
<table cellspacing="0" cellpadding="5" width="100%" border="1">
            <tbody>
                <tr>
                    <td bgcolor="#eeeeee"><a name="N1007A"><strong>容易实现</strong></a><strong><br>
正如您从展示视频（请参见下面 <a href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#resources">参考资料</a> 中的链接）可以看到的，敲打操作是由一系列指节敲打构成的。尽管 ThinkPad 的加速器是为保护它不受意外事件的影响，但太强力的振荡仍然会对硬盘造成损坏。因此我们必须小心。 </strong></td>
                </tr>
            </tbody>
        </table>
</td>
    </tr>
</tbody>
</table>
<p>很多在 2003 年以及这以后生产的 IBM（现在是 Lenovo）的 ThinkPads 中都有 HDAPS 硬件。如果您不确定自己的硬件配置，可以检查 Lenovo 的 Web 站点上关于您自己型号的机器的技术细节。如果您的机器上没有 ThinkPad，那么这段代码可能无法在您的笔记本上正常工作。</p>
<p>本文是在 x86 体系架构上编写的。本文中的代码是在 ThinkPad T42p 的两个不同模块上进行开发和测试的。有关 ThinkPad 硬件的链接，请参阅 <a href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#resources">参考资料</a> 部分。</p>
<p>如果您有一台 Apple MacBook，那么您可能也有这种加速器，并且可以使用相同的方法，通过内核访问它们。然而，本文中的代码并没有在 Apple 硬件上进行测试。</p>
<br>
<table cellspacing="0" cellpadding="0" width="100%" border="0">
<tbody>
    <tr>
        <td><img class="" src="/rc/legacy/blue_rule.gif" width="800"><br>
<img class="" src="/rc/legacy/c.gif" width="800"></td>
    </tr>
</tbody>
</table>
<table class="no-print" cellspacing="0" cellpadding="0" align="right">
<tbody>
    <tr align="right">
    <td><img class="" src="/rc/legacy/c.gif" width="800"><br>
    <table cellspacing="0" cellpadding="0" border="0">
    <tbody>
        <tr>
            <td valign="middle"><img class="" src="/rc/legacy/u_bold.gif" width="800"><br>
</td>
            <td valign="top" align="right"><a class="fbox" href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#main"><strong>回页首</strong></a></td>
        </tr>
    </tbody>
</table>
</td>
</tr>
</tbody>
</table>
<br>
<br>
<p><a name="N10091"><span class="atitle">软件要求</span></a></p>
<p>HDAPS 驱动程序必须包括在内核中才能启用对加速器的访问。试图对现有内核增加补丁也不会获得成功，因此我们建议从自己喜欢的镜像站点上下载最新的内核。新内核发行版中已经包含了对 HDAPS 驱动程序的支持。</p>
<p>启动内核配置选择程序，并在配置中包含 HDAPS 驱动程序。HDAPS 驱动程序位于 <strong>Device Drivers &gt; Hardware Monitoring Support &gt; IBM Hard Drive Active Protection System (hdaps) 选项中。更多的内核配置和安装过程已经超出了本文的范围，但是在 Web 站点上有很多教程可以提供具体的帮助；有关可以帮助我们入门的链接，请参阅 <a href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#resources">参考资料</a> 一节的内容。</strong></p>
<strong></strong>
<p><strong>本文是在 2.6.15.1 版本的内核上进行开发和测试的。</strong></p>
<strong><br>
</strong>
<table cellspacing="0" cellpadding="0" width="100%" border="0">
<tbody>
    <tr>
        <td><img class="" src="/rc/legacy/blue_rule.gif" width="800"><br>
<img class="" src="/rc/legacy/c.gif" width="800"></td>
    </tr>
</tbody>
</table>
<strong></strong>
<table class="no-print" cellspacing="0" cellpadding="0" align="right">
<tbody>
    <tr align="right">
    <td><img class="" src="/rc/legacy/c.gif" width="800"><br>
    <table cellspacing="0" cellpadding="0" border="0">
    <tbody>
        <tr>
            <td valign="middle"><img class="" src="/rc/legacy/u_bold.gif" width="800"><br>
</td>
            <td valign="top" align="right"><a class="fbox" href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#main"><strong>回页首</strong></a></td>
        </tr>
    </tbody>
</table>
</td>
</tr>
</tbody>
</table>
<strong><br>
<br>
</strong>
<p><strong><a name="N100A7"><span class="atitle">创建简单的敲打序列</span></a></strong></p>
<strong></strong>
<p><strong>从 <a href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#downloads">下载</a> 一节的链接中下载源代码，并从中找到 knockAge.pl 脚本。这就是让我们可以创建敲打序列的主要 Perl 程序，它还允许监听特殊的敲打序列并运行命令。下面让我们来介绍一下这个用户空间程序的用法，以及 knockAge.pl 程序的配置，然后再对这个函数进行回顾。</strong></p>
<strong></strong>
<p><strong>使用下面的命令运行 knockAge.pl 程序：</strong></p>
<strong></strong>
<p><code><strong>perl knockAge.pl -c</strong></code></p>
<strong></strong>
<p><strong>这会启动 Perl 程序来监听敲打事件并记录下它们之间的间距以供将来使用。一旦程序开始运行之后，对笔记本进行的敲打操作就会产生效果。我们并不需要在物理上移动自己的 ThinkPad 来注册敲打事件，如果 ThinkPad 在一个平面上，只要对其进行一些移动和滑行即可。我建议您用左右握住 ThinkPad 左边接近连接轴的地方，同时用右手在距离 LCD 底部 3 英寸的地方敲打显示屏即可。请参阅 <a href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#downloads">下载</a> 部分给出的视频展示，或参阅 <a href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#resources">参考资料</a> 中用来创建敲打序列的例子。</strong></p>
<strong></strong>
<p><strong>体验不同的敲打幅度和力度，从而了解 knockAge 程序能够捕获的事件判断率。对于创建复杂的敲打事件来说，这非常重要。</strong></p>
<strong></strong>
<p><strong>第一次真正尝试敲打应该非常简单，两次双击之间停留 0.5 秒，然后再次运行 <code>perl knockAge.pl -c</code>，在看到 “enter a knock sequence” 时稳定地敲打 LCD 边上两次，中间停留 0.5 秒。在 4 秒之后会自动超时（这是可以配置的），您所敲打的序列会被打印出来，这类似于下面的例子：</strong></p>
<strong></strong>
<p><code><strong>0 540031 _#_ (command here) _#_ &lt;comments here&gt;</strong></code></p>
<strong></strong>
<p><strong>让我们来分析一下这一行的内容：敲打序列，分隔符，命令区，分隔符，最后是注释区。我们的下一个步骤是将这行内容复制到 knockAge.pl 程序使用的默认配置文件 {$HOME}/.knockFile 中，该配置文件也可能是 /home/&lt;username&gt;/.knockFile 文件。在使用上面的敲打序列行创建好 .knockFile 文件之后，就可以对这行进行修改来运行程序了。将 <code>(command here)</code> 文本修改成 /bin/echo &#8220;double tap&#8221;，并将注释区的内容修改成更有意义的内容，例如：</strong></p>
<strong></strong>
<p><code><strong>0 540031 _#_ /bin/echo "double tap" _#_ Double tap event</strong></code></p>
<strong></strong>
<p><strong>现在我们已经修改好这个配置文件，可以打印一条通知了，接下来使用下面的命令在守护模式下运行 knockAge 脚本：</strong></p>
<strong></strong>
<p><code><strong>perl knockAge.pl</strong></code></p>
<strong></strong>
<p><strong>这个程序会在后台安静地监听 ~/.knockFile 所罗列的事件。请使用相同的间隔再次双击屏幕，您会看到在屏幕上打印出了 “double tap” 消息。如果我们希望更详细地了解 knockAge.pl 脚本是如何工作的，那么我们可以使用下面的命令在守护模式下运行它：</strong></p>
<strong></strong>
<p><code><strong>perl knockAge.pl -v</strong></code></p>
<strong><br>
</strong>
<table cellspacing="0" cellpadding="0" width="100%" border="0">
<tbody>
    <tr>
        <td><img class="" src="/rc/legacy/blue_rule.gif" width="800"><br>
<img class="" src="/rc/legacy/c.gif" width="800"></td>
    </tr>
</tbody>
</table>
<strong></strong>
<table class="no-print" cellspacing="0" cellpadding="0" align="right">
<tbody>
    <tr align="right">
    <td><img class="" src="/rc/legacy/c.gif" width="800"><br>
    <table cellspacing="0" cellpadding="0" border="0">
    <tbody>
        <tr>
            <td valign="middle"><img class="" src="/rc/legacy/u_bold.gif" width="800"><br>
</td>
            <td valign="top" align="right"><a class="fbox" href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#main"><strong>回页首</strong></a></td>
        </tr>
    </tbody>
</table>
</td>
</tr>
</tbody>
</table>
<strong><br>
<br>
</strong>
<p><strong><a name="N100F3"><span class="atitle">使用 xscreensaver 锁定屏幕或打开屏幕</span></a></strong></p>
<strong></strong>
<p><strong><a name="N100F9"><span class="smalltitle">创建 “password” 序列</span></a></strong></p>
<strong></strong>
<p><strong>使用下面的命令在 “create” 模式下运行 knockAge.pl 程序：</strong></p>
<strong></strong>
<p><code><strong>perl knockAge.pl -c</strong></code></p>
<strong></strong>
<p><strong>现在我们需要创建一个解锁的密码序列；我建议使用 “刮脸和理发的动作”。请确保每次您都可以以一贯精确的方式执行这个动作。尽管您可以通过修改参数来控制输入密码敲打操作所需要的精度，但是这仍然很难匹 配精确的时间。“刮脸和理发动作” 除了可以提供稳定的击打顺序之外，其复杂性和简单性对于屏保解锁密码来说也非常适合。下面是一个 “刮脸和理发动作” 的击打序列示例：</strong></p>
<strong></strong>
<p><code><strong>0 564025 1185795 621350 516038 960035 444421 _#_ /bin/echo "shave the haircut" _#_ two bits</strong></code></p>
<strong></strong>
<p><strong>在进行下一步操作之前，您应该体验一下上面的命令和 ~/.knockFile 配置文件中的双击命令。这可以在屏保运行时提供很好的帮助，它更难检测出敲打是否正确。</strong></p>
<strong></strong>
<p><strong><a name="N10112"><span class="smalltitle">xscreensaver 所使用的命令配置</span></a></strong></p>
<strong></strong>
<p><strong>以下设置假设您已经登录到了窗口管理器中，并且已经使用您的 userid 启动了xscreensaver 程序。例如，如果您正在运行 Fedora Core 4，并且使用 gdm 登录到 KDE 中，那么 xscreensaver 就会自动启动。因此，要激活它，则需要将双击命令从：</strong></p>
<strong></strong>
<p><code><strong>/bin/echo "double tap"</strong></code></p>
<strong></strong>
<p><strong>修改为：</strong></p>
<strong></strong>
<p><code><strong>xscreensaver-command -activate &amp;</strong></code></p>
<strong></strong>
<p><strong>现在，每次识别出有 “双击” 事件发生时，xscreensaver 程序都会使用所指定的内容来激活。一旦 screensaver 被激活，就可以通过输入密码（如果是这样配置的）对屏幕进行解锁。不过我们真正希望的是自己的朋友也可以使用密码解锁代码来解除屏保。因此，我们需要在 ~/.knockFile 文件中将下面的命令：</strong></p>
<strong></strong>
<p><code><strong>/bin/echo "shave the haircut"</strong></code></p>
<strong></strong>
<p><strong>替换为：</strong></p>
<strong></strong>
<p><code><strong>killall xscreensaver ; nohup xscreensaver -nosplash &gt;/dev/null 2&gt;/dev/null &amp;</strong></code></p>
<strong></strong>
<p><strong>这个命令会停止当前运行的所有 xscreensaver 程序，然后在后台再重新启动 xscreensaver。现在我们可以通过敲打屏幕边来重复加锁和解锁计算机屏保的过程。这比蓝牙提供的近似度加锁更加安全或更方便吗？答案可能是否定的。它更酷吗？当然！</strong></p>
<strong><br>
</strong>
<table cellspacing="0" cellpadding="0" width="100%" border="0">
<tbody>
    <tr>
        <td><img class="" src="/rc/legacy/blue_rule.gif" width="800"><br>
<img class="" src="/rc/legacy/c.gif" width="800"></td>
    </tr>
</tbody>
</table>
<strong></strong>
<table class="no-print" cellspacing="0" cellpadding="0" align="right">
<tbody>
    <tr align="right">
    <td><img class="" src="/rc/legacy/c.gif" width="800"><br>
    <table cellspacing="0" cellpadding="0" border="0">
    <tbody>
        <tr>
            <td valign="middle"><img class="" src="/rc/legacy/u_bold.gif" width="800"><br>
</td>
            <td valign="top" align="right"><a class="fbox" href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#main"><strong>回页首</strong></a></td>
        </tr>
    </tbody>
</table>
</td>
</tr>
</tbody>
</table>
<strong><br>
<br>
</strong>
<p><strong><a name="N1013B"><span class="atitle">更多例子</span></a></strong></p>
<strong></strong>
<p><strong>HDAPS 传感器和 knockAge.pl 程序提供了另外一种用户输入设备，我们可以使用它们以独特的方式进行输入。例如：</strong></p>
<strong></strong>
<ul><strong></strong>
<li><strong>如果计划在一个基础上测试新的 X 配置文件，可以将双击条目更改为重新启动配置好的 X 服务器。这样就不需要敲任何其他键来强制重启了。</strong> <strong></strong></li>
<li><strong>在命令区中可以放上我们喜欢使用的任何 shell 脚本，这样就可以使用双击来查看 e-mail。</strong> <strong></strong></li>
<li><strong>以最新的组合节拍进行敲打，让 ThinkLight 显示 WWII 代在 Kinakuta 的黄金存储设备的 Morse 密码位置。</strong> <strong></strong></li>
<li><strong>敲入 Morse 编码，防止键盘输入被记录。</strong> <strong></strong></li>
</ul>
<strong></strong>
<p><strong>请参阅 <a href="http://www-128.ibm.com/developerworks/cn/linux/l-knockage.html#resources">参考资料</a> 部分给出的有关将 ThinkPad 的倾斜度用于游戏、显示工具的例子。或者直接跳过这部分内容，将 Threshold 变量设置为 15，这样您使劲踢一脚 ThinkPad，它就会自动重启了。 </strong></p>
<strong></strong></td>
</tr>
</tbody>
</table></div></div>

  <footer>
    
    <p><a class="comments-link" href="/blog/2006/11/30/2/#disqus_thread" data-disqus-identifier="http://ifq.github.com/blog/2006/11/30/2/">View comments &raquo;</a></p>
    
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/2006/11/30/1/">对IBM笔记本加速度传感器的一点理解和想法</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2006-11-30T00:00:00+08:00" pubdate data-updated="true">Nov 30<span>th</span>, 2006</time>
         &bull; <a rel="bookmark" href="/blog/2006/11/30/1/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><div>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 一直以来,IBM笔记本都是走在技术的最前沿.回顾历史,许多先在笔记本常用的技术都是IBM率先引入笔记本上的.这也解释了为什么这么一个黑盒子能吸引那么多人,包括我.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 对于计算机来说,最容易损坏且能造成损失最大的就是硬盘了.因为硬盘不同于计算机的其他器件,它机械成分较高.尤其在笔记本这种苛刻的环境下损坏的可能更高.于是各个笔记本厂家都积极的研究硬盘的保护技术.先在比较流行的也比较有效的基于加速度传感器的保护装置也是由IBM率先引入笔记本的.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这种装置的基本原理是利用加速度传感器感知碰撞,跌落等造成的加速度突然变化,迅速的将磁头返回parking区域,避免磁头对盘面产生损伤.加速度传感器的响应速度一般都在微秒级,能够有效的做出响应.(其最早的应用就是在汽车的安全气囊上)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 查阅了下资料,IBM的硬盘保护装置APS(Active protection System)使用的加速度传感器好像是Analog Devices公司的<span class="productNumberHeading"><a target="_blank" href="http://www.analog.com/en/prod/0,2877,ADXL320,00.html">ADXL320</a>类似的传感器.AD公司的这个电子元件是有部分发放样片的,我之前也申请过一个数字温度传感器,使用DHL给我有机过来,大家有兴趣也可以去找找,如果运气好可以申请到一些很酷的电子元件(我上次申请的还有电子的陀螺仪,不过没有成功).<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 在windows下的IBM APS技术十分稳定,但是技术也相对封闭,官方没有提供扩展的开发功能. 
<div forimg="1" align="center">
<div forimg="1" align="right"><img class="" src="/rc/legacy/61d30ff48c08c0ee7709d77c.jpg" width="800"><br>
<div align="left">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 但是在Linux下情况则好的多.几位爱好者通过调试windows下的APS驱动得到了相关的硬件接口格式,并在linux下实现的加速度传感器的控制以及监控功能.但是这个驱动仅仅实现了加速度传感器的数据读取,没有做硬盘保护.所以还要配合一些Linux的程序和补丁来实现Disk head parking.不过,由于Linux下极高的开放度,让我们可以做其他更多的事情.如果大家有兴趣的话可以到<a target="_blank" href="http://hdaps.sourceforge.net/index.php?page=1">HDAPS</a>的官网以及<a target="_blank" href="http://www.thinkwiki.org/wiki/HDAPS">WiKi</a>去看看.现在基于APS有很多很酷的应用,比如作为Input device,做一些游戏,做安全防盗应用等(做游戏是不是太废硬盘了?本来是拿来保护硬盘的,结果拿来玩游戏猛摇<img class="" src="/rc/legacy/i_f12.gif" width="800">).其中的防盗应用倒是很吸引我,对我来说有很大的价值.在笔记本锁定的情况下发生大的振动就以声音等形式报警,在一些场合下还是很适用的吧.这里还有一段<a target="_blank" href="http://www.youtube.com/watch?v=0QSX4Bq3Pdw&amp;mode=related&amp;search=">视频</a>可以作为参考,是基于敲打的linux命令输入.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 目前我还没有做过相关的开发,因为我先在一般都是在windows下用虚拟机跑Linux,没有机会体验HDAPS驱动.不过我想这种技术在windows下应该更有利用的价值.我是个Linux的爱好者,但不是一个崇拜者.我认为技术很重要,但技术是为应用服务的.如果做出来的技术没有更多的人能够体验到,那也不能算是成功的技术.linux下固然有很好的技术交流分为,但是试问有多少人的IBM本本整天跑在Linux之下呢.所以我希望能够把这种技术从Linux再挪回到windows上,为更多人所用.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 粗略的查了下网上的资料比较少,基于windows的就更少了.不知道大家有没有对这方面的了解,说不定谁已经在windows下实现了这些.希望大家多多交流,今后我也将持续关注这个技术.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 吃饭去了.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
</div>
</div>
</div>
</span><span class="productNumberHeading"><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></div></div>

  <footer>
    
    <p><a class="comments-link" href="/blog/2006/11/30/1/#disqus_thread" data-disqus-identifier="http://ifq.github.com/blog/2006/11/30/1/">View comments &raquo;</a></p>
    
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/2006/11/29/3/">我的baidu处女作日志,总结下最近应聘的情况吧</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2006-11-29T00:00:00+08:00" pubdate data-updated="true">Nov 29<span>th</span>, 2006</time>
         &bull; <a rel="bookmark" href="/blog/2006/11/29/3/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><div><div align="left" >&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 中国人见面打招呼喜欢说:&quot;吃了没?&quot;,中国大四学生见面则喜欢说:&quot;签了没?&quot;.<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 这是我最近的切身体会.不禁让我想到以前一件好笑的事情:一天我走在去实验室的路上,老远碰到一位同学迎面走来.我们互相发现了对方,都say hi示意.但是我俩不是很熟,突然想不到该说什么好,于是四目相对,两人逐渐逼近,场面极为尴尬.终于中国几千年优秀的传统文化对我的熏陶让我鳖出了一句:&quot;吃了么?&quot;.他回了句:&quot;还没&quot;.我明显可以从他的表情看出他也有如负重释感觉&#8230;<img class="" src="/rc/legacy/i_f12.gif" width="800">等我回过神来才意识到自己怎么也会落入这种俗套,不过还是总比面面相觑要好的多.于是&quot;吃了没&quot;也成了我在危机情况下的候补招呼语.<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  不过最近情况不一样了,大家都在找工作了.不管是熟人还是普通同学见面都可以聊很长时间.前段时间我也参加了大大小小7,8个招聘会.整天跑来跑去也来的整理,这两天终于停下来等了,可以把自己的一些体验写下来和大家分享了.(以前尽看别人写这种东东,今年峰回路转终于轮上我了<img class="" src="/rc/legacy/i_f02.gif" width="800">)<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  首先有点可惜的是11月之前我一直在做项目,没有关注过应聘的事情,这让我错过了很多大公司的简历投递,比如华为,联想.这让我郁闷了好几天.天天念叨没有人要了怎么办啊&#8230;<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  11月一开始就狂跑招聘会.几乎天天早上<font color="#ff0000" >7点</font >起床!!!(对我来说比较难)通过一周的应聘让我了解到了目前社会上的需求,也让我安定了不少.先在回想起来,目前重点考虑的几个公司都是我第一,二天参加应聘所投的公司&#8230;首先还是来历数一下我应聘的这几个公司:<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  第一天去面试是一个上海的派遣公司,可能大家都怎么听说过,叫智锐电子什么什么东东.这个公司是要把招的嵌入式工程师送到日本去工作的.本来当时对于日本公司的排斥心理还是很大的,去这个招聘会也只是想了解下应聘的流程.但是先在却是我最主要的考虑对象,应聘这段时间心理变化确实挺大的.本来我一心想要留在成都的,觉得生活安逸之类的.但是发现电子行业在成都还是太少了,不得不扩大了目标.<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; 言归正传,这个日本公司的招聘流程比较特别:先笔试,再面试,再发给你一些学习资料,过一个月再笔试,再面试.通过之后签约,签约之后公司培训日语,帮你办签证,到毕业直接去日本.月薪RMB15k左右,这个对于本科生来说还是想到具有诱惑力的.(我几乎是在宣讲会上就对这个公司态度大转变&#8230;有点世俗哈&#8230;不过这么轻易就能有出国锻炼的机会,真是可遇而不可求啊)当时第一轮笔试是英文的嵌入式方面的基础类试题,我做的一般般.然后第二天早上面试,面试官是一个日本人.英文对话了10分钟,大概就是些自我介绍,职业规划之类的.之后也主要HR类型的面试,没有技术面.再后来就是回来学习公司发的资料,等待12月初的第二轮面试了.其间公司给我打过两个电话问我有没有offer,还会不会参加他们的面试之类,我都如实回答了.<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  第二天面试了SiS矽统公司,也是个很难得的机会,不过最后还是没有招我,失落了好几天.跑去电子科大发现SiS在招聘,3个SiS的PLMM坐在那边做接待工作.提前就知道SiS要招聘,但是没想到这么快就来了.高中就知道这个公司,对它的印象还不错,于是拿出简历上去试一试.我靠!台湾MM那叫一个客气啊,而且声音又温柔,听得我身上还真有点痒&#8230;今年SiS是只招硕士的,但是他们还是给了我一个机会.(这和上海一个垃圾公司的做法完全形成鲜明对比,通知我面试去了又说不要本科&#8230;) 首先还是笔试,题量不大,但是英文的,内容还是比较基础,有关于内存,总线之类的问题.面试也很简单,都是把我的项目经验以及基本情况介绍了一遍.最后面试官给我的评价是&quot;相当有竞争力&quot;,&quot;还是十分优秀的&quot;.这给我添加了很多信心,也让我觉得似乎可以到SiS工作了,不过最后他们还是选择了硕士.不过他们的态度还是很让我感动.<br />
<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  原来可以写很多东西啊&#8230;还有很多今天懒得写了,以后再写吧.<br />
&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;  </div ></div></div>

  <footer>
    
    <p><a class="comments-link" href="/blog/2006/11/29/3/#disqus_thread" data-disqus-identifier="http://ifq.github.com/blog/2006/11/29/3/">View comments &raquo;</a></p>
    
    
    
  </footer>


    </article>
  
    










    <article >
      
  <header>
    <h1 class="entry-title">

<a href="/blog/2006/11/29/2/">转载.谈谈搜索引擎作弊问题Search Engine Anti-SPAM</a>

</h1>

    
      <p class="meta">
        








  


<time datetime="2006-11-29T00:00:00+08:00" pubdate data-updated="true">Nov 29<span>th</span>, 2006</time>
         &bull; <a rel="bookmark" href="/blog/2006/11/29/2/">Permalink</a>
      </p>
    
  </header>

<div class="entry-content"><div><h3>数学之美 系列十七 闪光的不一定是金子 谈谈搜索引擎作弊问题(Search Engine Anti-SPAM)</h3>
<p class="byline-timestamp"><span>2006年11月28日 上午 03:18:00</span></p>
Google 研究员 吴军<br>
<br>
自从有了搜索引擎，就有了针对搜索引擎网页排名的作弊(SPAM)。以至于用户发现在搜索引擎中排名靠前的网页不一定就是高质量的，用句俗话说，闪光的不一定是金子。<br>
<br>
搜索引擎的作弊，虽然方法很多，目的只有一个，就是采用不正当手 
<div style="DIRECTION: ltr"><wbr></wbr>段提高自己网页的排名。早期最常见的作弊方法是重复关键词<wbr></wbr>。比如一个卖数码相机的网站，重复地罗列各种数码相机的品牌，如尼康<wbr></wbr>、佳能和柯达等等。为了不让读者看到众多讨厌的关键词<wbr></wbr>，聪明一点的作弊者常用很小的字体和与背景相同的颜色来掩盖这些<wbr></wbr>关键词。其实，这种做法很容易被搜索引擎发现并纠正。<br>
<br>
在有了网页排名<wbr></wbr>(page rank)以后，作弊者发现一个网页被引用的连接越多，排名就可能越靠前<wbr></wbr>，于是就有了专门卖链接和买链接的生意。比如，有人自己创建成百<wbr></wbr>上千个网站，这些网站上没有实质的内容，只有到他们的客户网站的<wbr></wbr>连接。这种做法比重复关键词要高明得多，但是还是不太难被发现<wbr></wbr>。因为那些所谓帮别人提高排名的网站，为了维持生意需要大量地卖链<wbr></wbr>接，所以很容易露马脚。（这就如同造假钞票，当某一种假钞票的流通量相当大以后，就容易找到根源了。）再以后，又有了形形色色的作弊方式<wbr></wbr>，我们就不在这里一一赘述了。<br>
<br>
几年前，我加入Google做的第一件事就是消除网络作弊<wbr></wbr>。在Google最早发现搜索引擎作弊的是Matt Cutts，他在我加入Google前几个月开始研究这个问题<wbr></wbr>，后来，辛格，马丁和我先后加入进来。我们经过几个月的努力<wbr></wbr>，清除了一半的作弊者。(当然，以后抓作弊的效率就不会有这么高了。<wbr></wbr>）其中一部分网站从此&#8221;痛改前非&#8221;，但是还是有很多网站换一种作弊方法<wbr></wbr>继续作弊，因此，抓作弊成了一种长期的猫捉老鼠的游戏<wbr></wbr>。虽然至今还没有一个一劳永逸地解决作弊问题的方法，但是<wbr></wbr>，Google基本做到了对于任何已知的作弊方法<wbr></wbr>，在一定时间内发现并清除它，从而总是将作弊的网站的数量控制在一<wbr></wbr>个很小的比例范围。<br>
<br>
抓作弊的方法很像信号处理中的去噪音的办法。学过信息论和有信号<wbr></wbr>处理经验的读者可能知道这么一个事实，我们如果在发动机很吵的汽<wbr></wbr>车里用手机打电话，对方可能听不清；但是如果我们知道了汽车发动<wbr></wbr>机的频率，我们可以加上一个和发动机噪音相反的信号<wbr></wbr>，很容易地消除发动机的噪音，这样，收话人可以完全听不到汽车的噪音<wbr></wbr>。事实上，现在一些高端的手机已经有了这种检测和消除噪音的功能<wbr></wbr>。消除噪音的流程可以概括如下：<br>
<img class="" src="/rc/legacy/math-782969.gif" width="800"><br>
在图中，原始的信号混入了噪音，在数学上相当于两个信号做卷积<wbr></wbr>。噪音消除的过程是一个解卷积的过程。这在信号处理中并不是什么<wbr></wbr>难题。因为第一，汽车发动机的频率是固定的，第二<wbr></wbr>，这个频率的噪音重复出现，只要采集几秒钟的信号进行处理就能做<wbr></wbr>到。从广义上讲，只要噪音不是完全随机的、并且前后有相关性<wbr></wbr>，就可以检测到并且消除。（事实上，完全随机不相关的高斯白噪音<wbr></wbr>是很难消除的。）<br>
<br>
搜索引擎的作弊者所作的事，就如同在手机信号中加入了噪音<wbr></wbr>，使得搜索结果的排名完全乱了。但是，这种人为加入的噪音并不难<wbr></wbr>消除，因为作弊者的方法不可能是随机的（否则就无法提高排名了）<wbr></wbr>。而且，作弊者也不可能是一天换一种方法，即作弊方法是时间相关<wbr></wbr>的。因此，搞搜索引擎排名算法的人，可以在搜集一段时间的作弊信<wbr></wbr>息后，将作弊者抓出来，还原原有的排名。当然这个过程需要时间<wbr></wbr>，就如同采集汽车发动机噪音需要时间一样，在这段时间内<wbr></wbr>，作弊者可能会尝到些甜头。因此，有些人看到自己的网站经过所谓<wbr></wbr>的优化（其实是作弊），排名在短期内靠前了，以为这种所谓的优<wbr></wbr>化是有效的。但是，不久就会发现排名掉下去了很多。这倒不是搜索引擎<wbr></wbr>以前宽容，现在严厉了，而是说明抓作弊需要一定的时间<wbr></wbr>，以前只是还没有检测到这些作弊的网站而已。<br>
<br>
还要强调一点<wbr></wbr>，Google抓作弊和恢复网站原有排名的过程完全是自动的(并没有个人的好恶）<wbr></wbr>，就如同手机消除噪音是自动的一样。一个网站要想长期排名靠前<wbr></wbr>，就需要把内容做好，同时要和那些作弊网站划清界限。</div></div></div>

  <footer>
    
    <p><a class="comments-link" href="/blog/2006/11/29/2/#disqus_thread" data-disqus-identifier="http://ifq.github.com/blog/2006/11/29/2/">View comments &raquo;</a></p>
    
    
    
  </footer>


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/31/">&larr; Older</a>
    
    <a href="/archives/">Blog Archives</a>
    
    <a class="next" href="/blog/page/29/">Newer &rarr;</a>
    
  </div>
</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/03/23/cage-for-kira/">龙猫柜笼制作系列-1</a>
      </li>
    
      <li class="post">
        <a href="/blog/2013/01/16/bedlamp/">悬挂式床头灯</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/11/10/ps-memo/">802.11协议节电学习memo</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/29/upgrade-octopress/">更新octopress博客系统后的笔记</a>
      </li>
    
      <li class="post">
        <a href="/blog/2012/10/28/roubo-workbench-5/">Roubo Style Workbench - 靖天木工桌 5/5</a>
      </li>
    
  </ul>
</section>










<section>
  <h1>Categories</h1>
  <ul id="category-list">
    <li><a href='/blog/categories/binary'>binary (9)</a></li><li><a href='/blog/categories/cool'>cool (1)</a></li><li><a href='/blog/categories/handtool'>handtool (4)</a></li><li><a href='/blog/categories/ieee802-11'>IEEE802.11 (1)</a></li><li><a href='/blog/categories/legacy'>legacy (279)</a></li><li><a href='/blog/categories/octopress'>octopress (2)</a></li><li><a href='/blog/categories/orgmode'>orgmode (2)</a></li><li><a href='/blog/categories/other'>other (1)</a></li><li><a href='/blog/categories/woodworking'>woodworking (12)</a></li><li><a href='/blog/categories/workbench'>workbench (5)</a></li>
  </ul>
</section>

<section>
  <h1>Recent Comments</h1>
  <div id="dsq-recentcomments" class="dsq-widget"><script type="text/javascript" src="http://disqus.com/forums/ifq/recent_comments_widget.js?hide_avatars=1"></script></div>
</section>

<section>
<iframe frameborder="0" scrolling="no" src="http://show.v.t.qq.com/index.php?c=show&a=index&n=Jingtianwang&w=0&h=548&fl=2&l=30&o=25&co=4&cs=C0C0C0_F2F2F2_4E5959_99A4AD" width="100%" height="548"></iframe>
</section>


  
</aside>

<center><a href="http://www.freedomain.co.nr/" title="Free Domain Name"><img src="http://ecozooa.imdrv.net/soof62.gif" alt="Free Domain Name" style="width:88px;height:31px;border:0;" /></a><a href='http://www.urlfan.com/?via=b' ><img src='http://i.urlfan.com/?r=7ec49' border=0></a><a href="https://plus.google.com/115086707443303900229" rel="publisher">在 Google+ 上关注我们</a></center>

    </div>
  </div>
  <footer role="contentinfo">Copyright &copy; 2013

    靖天
    (一个热爱木工的软件工程师)


</footer>
  <script src="/javascripts/slash.js"></script>


<script type="text/javascript">
      var disqus_shortname = 'ifq';
			var disqus_developer = '0';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>






</body>
</html>
